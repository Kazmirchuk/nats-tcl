# Copyright (c) 2021 Petro Kazmirchuk https://github.com/Kazmirchuk

# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language governing permissions and  limitations under the License.

startNats NATS

set conn [nats::connection new "ExtraOptions"]
[$conn logger]::setlevel debug

$conn configure -servers nats://localhost:4222

#test extra_opts-6 "Check verbose and pedantic modes" -body {
#    $conn configure -verbose true -pedantic true
#    $conn connect -async
#    set obs [test_utils::chanObserver new [set ${::conn}::sock] b]
#    test_utils::sleep 500
#    $conn publish foo bar
#    test_utils::sleep 600
#    set chanData [$obs getChanData]
#    assert {$chanData eq {CONNECT {"verbose":true,"pedantic":true,"tls_required":false,"name":"","lang":"Tcl","version":"0.9","protocol":1,"echo":false}}}
#    assert {[set ${conn}::status] eq $nats::status_connected}
#    
#}

test extra_opts-2 "Check the echo=false option" -body {
    set test_utils::simpleMsg ""
    $conn configure -echo false
    $conn connect -async
    set obs [test_utils::chanObserver new $conn w]
    while {[set ${conn}::status] ne $nats::status_connected} {
        vwait ${conn}::status
    }
    set chanData [$obs getChanData]
    $obs destroy
    
    set pos [string first " " $chanData] ;# skip CONNECT straight to the beginning of JSON
    set connectDict [json::json2dict [string range $chanData [expr {$pos + 1}] end]]
    assert {[dict get $connectDict echo] eq "false"}
        
    $conn subscribe no_echo -callback test_utils::simpleCallback
    $conn publish no_echo "cold is the void" ;# we will not get this message back
    after 300 [list set test_utils::simpleMsg "timeout"]
    duration {
        vwait test_utils::simpleMsg
    } elapsed
    assert {[approx $elapsed 300]}
    assert {$test_utils::simpleMsg eq "timeout"}
    # but a request to another subscriber still works fine
    startResponder no_echo
    set result [$conn request no_echo "0 hello"]
    assert {$result eq "hello"}
    stopResponder $conn no_echo
    $conn disconnect
    $conn reset -echo
}

test extra_opts-3 "PING/PONG protocol initiated by client" -body {
    $conn configure -ping_interval 1000 ;# default is 2 minutes
    $conn connect
    set obs [test_utils::chanObserver new $conn b]
    duration {
        vwait ${conn}::pong
    } elapsed
    assert {$elapsed >= 1000 && $elapsed < 1300}
    lassign [$obs getChanData 0 0] readData writtenData
    $obs destroy
    # check that the exchange occurred exactly once
    assert {[lsearch -all $writtenData "PING"] == 0}
    assert {[lsearch -all $readData "PONG"] == 0}
    
    $conn disconnect
    $conn reset -ping_interval
}

stopNats NATS

test extra_opts-4.1 "PING/PONG protocol initiated by server" -body {
    # I can't pass ping_interval as a command line argument to the NATS server, so have to create a config file
    set conf [tcltest::makeFile {
        ping_interval: "2s"
        ping_max: 1
    } quick_ping.conf ]
    startNats quick_ping -c $conf
    $conn connect
    set obs [test_utils::chanObserver new $conn b]
    test_utils::sleep 2400
    lassign [$obs getChanData 0 0] readData writtenData
    $obs destroy
    # check that the exchange occurred exactly once
    assert {[lsearch -all $writtenData "PONG"] == 0}
    assert {[lsearch -all $readData "PING"] == 0}
} -cleanup {tcltest::removeFile quick_ping.conf}

test extra_opts-4.2 "PING/PONG - no response from the client" -body {
    # access to a private variable only for test purposes!
    trace add variable ${conn}::outBuffer write [lambda {var idx op } {
        upvar $var buffer
        set pos [lsearch $buffer "PONG"]
        if {$pos == -1} {
            return
        }
        set buffer [lsearch -inline -all -not -exact $buffer "PONG"] ;# do not send PONG to the server
        puts "Deleted PONG"
    }]
    # wait for the next PING/PONG exchange initiated by the server
    # we do not respond to PING, so the server will report an error with -ERR and close the socket
    # which will make the client go into the reconnecting mode
    duration {
        vwait ${conn}::status
    } elapsed
    assert {[dict get [set ${conn}::last_error] code] eq "NATS STALE_CONNECTION"}
    assert {[set ${conn}::status] == $nats::status_reconnecting}
    # after sending PING, the server will wait for 2s more before declaring 'Stale Connection'
    assert {$elapsed < 5000}
    $conn disconnect
    unset ${conn}::outBuffer ;# the easiest way to get rid of the trace on outBuffer
    set ${conn}::outBuffer [list]
}

stopNats quick_ping

test extra_opts-5 "PING/PONG - no response from the server" -setup {
    # make a fake NATS server that does not respond to PING
    startFakeServer
    set handler {
        proc handler {channel line} {
            if {$line eq "PING"} {
                puts $channel FAKE_PONG
            }
        }
    }
    comm::comm send 4223 $handler
} -body {
    $conn configure -ping_interval 1000
    # default max_outstanding_pings=2
    $conn connect
    duration {
        # the client will send 2 PINGs without reply; when Pinger runs for the 3rd time, it will raise the error
        # and the client will go into reconnecting
        vwait ${conn}::status
    } elapsed
    assert {[dict get [set ${conn}::last_error] code] eq "NATS STALE_CONNECTION"}
    assert {[set ${conn}::status] == $nats::status_reconnecting}
    assert {[approx $elapsed 3000]}
    $conn reset -ping_interval
} -cleanup {
    stopFakeServer
}


$conn destroy
# connect fails with empty server pool
#$conn destroy
#stopNats NATS

tcltest::cleanupTests
