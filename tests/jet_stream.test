# Copyright (c) 2021-2022 Petro Kazmirchuk https://github.com/Kazmirchuk
# Copyright (c) 2021 ANT Solutions https://antsolutions.eu/

# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language governing permissions and  limitations under the License.

# Test summary:
# - sync, async consuming from a durable consumer with ACK
# - sync, async publishing to a stream
# - async consuming messages in batches
source test_utils.tcl

set stream_name MY_STREAM
set consumer_name PULL_CONSUMER

startNats NATS_JS -js

set conn [nats::connection new]
#debugLogging $conn

$conn configure -servers nats://localhost:4222
$conn connect
set jet_stream [$conn jet_stream -timeout 1000]

test jet_stream-setup "Create a stream and pull consumer" -body {
    set response [$jet_stream add_stream $stream_name -subjects [list test.*] -storage memory]
    assert {[dict get $response did_create]}
    set response [$jet_stream add_pull_consumer $stream_name $consumer_name -ack_wait 1000] ;# rather short ack_wait=1s
    assert {[dict get $response name] eq $consumer_name}
}

test jet_stream-1.1 "Publish and sync consume" -body {
    $conn publish test.1 "msg 1"
    duration {
        set msg [$jet_stream consume $stream_name $consumer_name]
    } elapsed
    assert {$elapsed < 100}
    assert {[dict get $msg subject] eq "test.1"} 1
    dict get $msg data
} -result "msg 1"

test jet_stream-1.2 "Sync consume redelivered message and ACK" -body {
    sleep 1000 ;# =ack_wait
    # message has not been ACK, so it should be redelivered
    duration {
        set msg [$jet_stream consume $stream_name $consumer_name]
    } elapsed
    assert {$elapsed < 100}
    $jet_stream ack $msg
    dict get $msg data
} -result "msg 1"

test jet_stream-1.3 "No message left after ACK - timeout" -body {
    duration {
        # the timeout could be signalled either by a timer in the client or by NATS Server - it will return HMSG Status=408
        # in both cases, we throw ErrTimeout, but error messages will differ
        catch {$jet_stream consume $stream_name $consumer_name -timeout 1000} err errOpts
    } elapsed
    assert {[approx $elapsed 1000]}
    dict get $errOpts -errorcode
} -result {NATS ErrTimeout}

test jet_stream-2.1 "Publish and async consume" -body {
    $conn publish test.2 "msg 2"
    duration {
        $jet_stream consume $stream_name $consumer_name -callback test_utils::asyncReqCallback
    } elapsed
    assert {$elapsed < 50} ;# async request returns immediately
    
    wait_for test_utils::simpleMsg 500
    dict get $test_utils::simpleMsg data
} -result "msg 2"

test jet_stream-2.2 "Async consume and ACK" -body {
    sleep 1000 ;# =ack_wait
    duration {
        $jet_stream consume $stream_name $consumer_name -callback test_utils::asyncReqCallback
    } elapsed
    assert {$elapsed < 50} ;# async request returns immediately
    
    wait_for test_utils::simpleMsg 500
    $jet_stream ack $test_utils::simpleMsg
    dict get $test_utils::simpleMsg data
} -result "msg 2"

test jet_stream-2.3 "Async consume timeout" -body {
    duration {
        $jet_stream consume $stream_name $consumer_name -callback test_utils::asyncReqCallback -timeout 1500
    } elapsed
    assert {$elapsed < 50} ;# async request returns immediately
    
    duration {
        wait_for test_utils::simpleMsg 2000
    } elapsed
    assert {[approx $elapsed 1500]}

    set test_utils::simpleMsg
} -result timeout

test jet_stream-5.1 "Publish message to JetStream sync" -body {
    $jet_stream publish test.3 "msg 3"
} -result [dict create stream $stream_name seq 3]

test jet_stream-5.2 "Publish message to JetStream async" -body {
    duration {
        $jet_stream publish test.4 "msg 4" -callback [lambda {timedOut pubAck pubError} {
            set ::pubAck $pubAck
        }]
    } elapsed
    assert {$elapsed < 50}
    
    wait_for ::pubAck 1000
} -result [dict create stream $stream_name seq 4] -cleanup {
    # we are not going to consume these messages
    $jet_stream purge_stream $stream_name
}

test jet_stream-5.3 "Publish message to JetStream sync - no such stream" -body {
    $jet_stream publish not.exists "not.exists"
} -result "No responders available for request" -errorCode {NATS ErrNoResponders} 

test jet_stream-5.4 "Publish message to JetStream async - no such stream" -body {
    duration {
        $jet_stream publish not.exists "not.exists" -callback [lambda {timedOut pubAck pubError} {
            set ::timedOut $timedOut
        }]
    } elapsed
    assert {$elapsed < 50}
    duration {
        wait_for ::timedOut 2000
    } elapsed
    set timedOut
} -result 1

test jet_stream-9 "Consume messages in batches" -body {
    # publish 8 messages and consume them in batches of 5
    for {set i 0} { $i < 8} {incr i} {
        $conn publish test.1 $i
    }
    set msg_count 0
    set cb [lambda {timedOut msg} {
        $::jet_stream ack $msg
        assert {!$timedOut}
        assert {[dict get $msg subject] eq "test.1"} 1
        assert {[dict get $msg data] == $::msg_count} 1
        incr ::msg_count
    }]
    $jet_stream consume $stream_name $consumer_name -batch_size 5 -callback $cb
    while {$msg_count != 5} {
        wait_for ::msg_count 2000
    }
    $jet_stream consume $stream_name $consumer_name -batch_size 5 -callback $cb
    while {$msg_count != 8} {
        wait_for ::msg_count 2000
    }
}

$conn destroy
stopNats NATS_JS
tcltest::cleanupTests
