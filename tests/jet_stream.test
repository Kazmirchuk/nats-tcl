# Copyright (c) 2021-2023 Petro Kazmirchuk https://github.com/Kazmirchuk
# Copyright (c) 2021 ANT Solutions https://antsolutions.eu/

# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language governing permissions and  limitations under the License.

# Test summary:
# - sync, async consuming from a durable consumer with ACK
# - sync, async publishing to a stream
# - async consuming messages in batches
source test_utils.tcl

set stream_name MY_STREAM
set consumer_name PULL_CONSUMER

startNats NATS_JS -js

set conn [nats::connection new "JS" -log_chan [tcltest::outputChannel]]

$conn configure -servers nats://localhost:4222
$conn connect
set jet_stream [$conn jet_stream -timeout 1000]

test jet_stream-setup "Create a stream and pull consumer" -body {
    set response [$jet_stream add_stream $stream_name -subjects [list test.*] -storage memory]
    assert {[dict get $response did_create]}
    set response [$jet_stream add_pull_consumer $stream_name $consumer_name -ack_wait 1000] ;# rather short ack_wait=1s
    assert {[dict get $response name] eq $consumer_name}
}

test jet_stream-1.1 "Publish and sync consume" -body {
    $conn publish test.1 "msg 1"
    duration {
        set msg [lindex [$jet_stream consume $stream_name $consumer_name] 0]
    } elapsed
    assert {$elapsed < 100}
    assert {[nats::msg subject $msg] eq "test.1"} 1
    nats::msg data $msg
} -result "msg 1"

test jet_stream-1.2 "Sync consume redelivered message and ACK" -body {
    sleep 1000 ;# =ack_wait
    # message has not been ACK, so it should be redelivered
    duration {
        set msg [lindex [$jet_stream consume $stream_name $consumer_name] 0]
    } elapsed
    assert {$elapsed < 100}
    $jet_stream ack $msg
    nats::msg data $msg
} -result "msg 1"

test jet_stream-1.3 "No message left after ACK - timeout" -body {
    duration {
        # force a client-side timeout that will raise ErrTimeout
        catch {$jet_stream consume $stream_name $consumer_name -timeout 500 -expires 1000} err errOpts
    } elapsed
    assert {[approx $elapsed 500]}
    dict get $errOpts -errorcode
} -result {NATS ErrTimeout}

test jet_stream-5.1 "Publish message to JetStream sync" -body {
    $jet_stream publish test.3 "msg 3"
} -result [dict create stream $stream_name seq 2]

test jet_stream-5.2 "Publish message to JetStream async" -body {
    duration {
        $jet_stream publish test.4 "msg 4" -callback [lambda {timedOut pubAck pubError} {
            set ::pubAck $pubAck
        }]
    } elapsed
    assert {$elapsed < 50}
    
    wait_for ::pubAck 1000
} -result [dict create stream $stream_name seq 3] -cleanup {
    # we are not going to consume these messages
    $jet_stream purge_stream $stream_name
}

test jet_stream-5.3 "Publish message to JetStream sync - no such stream" -body {
    $jet_stream publish not.exists "not.exists"
} -result "No responders available for request" -errorCode {NATS ErrNoResponders} 

test jet_stream-5.4 "Publish message to JetStream async - no such stream" -body {
    duration {
        $jet_stream publish not.exists "not.exists" -callback [lambda {timedOut pubAck pubError} {
            set ::timedOut $timedOut
        }]
    } elapsed
    assert {$elapsed < 50}
    duration {
        wait_for ::timedOut 2000
    } elapsed
    set timedOut
} -result 1

test jet_stream-9 "Consume messages in batches" -body {
    # publish 8 messages and consume them in batches of 5
    for {set i 0} { $i < 8} {incr i} {
        $jet_stream publish test.1 $i
    }
    set msg_count 0
    set cb [lambda {timedOut msg} {
        
        assert {!$timedOut}
        
        incr ::msg_count
    }]
    set msgList [$jet_stream consume $stream_name $consumer_name -batch_size 5 -timeout 1000]
    assert {[llength $msgList] == 5} 1
    set i 0
    foreach msg $msgList {
        $jet_stream ack $msg
        assert {[nats::msg subject $msg] eq "test.1"} 1
        assert {[nats::msg data $msg] == $i} 1
        incr i
    }
    set msgList [$jet_stream consume $stream_name $consumer_name -batch_size 5 -timeout 1000]
    assert {[llength $msgList] == 3}
    foreach msg $msgList {
        $jet_stream ack $msg
        assert {[nats::msg subject $msg] eq "test.1"} 1
        assert {[nats::msg data $msg] == $i} 1
        incr i
    }
}

$jet_stream destroy
$conn destroy
stopNats NATS_JS
tcltest::cleanupTests
