# Copyright (c) 2023 Petro Kazmirchuk https://github.com/Kazmirchuk
# Copyright (c) 2023 ANT Solutions https://antsolutions.eu/

# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language governing permissions and  limitations under the License.
source test_utils.tcl

set bucket MY_TEST_BUCKET
startNats NATS_JS --jetstream --store_dir [tcltest::temporaryDirectory]

set conn [nats::connection new "KV" -log_chan [tcltest::outputChannel]]
$conn configure -servers nats://localhost:4222
$conn connect
set js [$conn jet_stream]
set kv [$js create_kv_bucket $bucket -history 64]

test key_value_watchers-history-1 "Get history for an empty bucket" -body {
    $kv history >
} -result * -match glob -errorCode {NATS ErrKeyNotFound}

test key_value_watchers-keys-1 "Get keys for an empty bucket" -body {
    $kv keys
} -result * -match glob -errorCode {NATS ErrKeyNotFound}

test key_value_watchers-history-2 "Get history for a key" -setup {
    $kv put key1 value1_1
    $kv put key1 value1_2
    $kv delete key1
    $kv put key1 value1_3
} -body {
    set entries [$kv history key1]
    assert {[llength $entries] == 4} 1
    assert {[dict_in [dict create \
                      bucket $bucket \
                      key key1 \
                      value value1_1 \
                      revision 1 \
                      operation PUT] [lindex $entries 0]]}
    assert {[dict_in [dict create \
                      bucket $bucket \
                      key key1 \
                      value value1_2 \
                      revision 2 \
                      operation PUT] [lindex $entries 1]]}
    assert {[dict_in [dict create \
                      bucket $bucket \
                      key key1 \
                      value {} \
                      revision 3 \
                      operation DEL] [lindex $entries 2]]}
    assert {[dict_in [dict create \
                      bucket $bucket \
                      key key1 \
                      value value1_3 \
                      revision 4 \
                      operation PUT] [lindex $entries 3]]}
} -result ""

test key_value_watchers-history-3 "Get history for a key that doesn't exist" -body {
    $kv history key2
} -result * -match glob -errorCode {NATS ErrKeyNotFound}

test key_value_watchers-history-4 "Get history for a purged key" -setup {
    $kv purge key1
    $kv put key1 value1_4
} -body {
    set entries [$kv history key1]
    assert {[llength $entries] == 2} 1
    assert {[dict_in [dict create \
                      bucket $bucket \
                      key key1 \
                      value {} \
                      revision 5 \
                      operation PURGE] [lindex $entries 0]]}
    assert {[dict_in [dict create \
                      bucket $bucket \
                      key key1 \
                      value value1_4 \
                      revision 6 \
                      operation PUT] [lindex $entries 1]]}
} -result ""

test key_value_watchers-keys-2 "Get all keys" -setup {
    $kv delete key1
    $kv put key2 value2
    $kv put key3 value3
} -body {
    lsort [$kv keys]
} -result {key2 key3}

set watcherCallback [lambda {entry} {
    lappend ::allEntries $entry
}]

test key_value_watchers-watch-1 "Watch one key" -body {
    set watcher [$kv watch key2 -callback $watcherCallback]
    $kv put key2 value3
    $kv delete key2
    while {[llength $allEntries] < 4} {
        wait_for ::allEntries
    }
    assert {[dict_in [dict create \
                      bucket $bucket \
                      key key2 \
                      value value2 \
                      operation PUT] [lindex $allEntries 0]]}
    assert {[lindex $allEntries 1] eq ""}
    assert {[dict_in [dict create \
                      bucket $bucket \
                      key key2 \
                      value value3 \
                      operation PUT] [lindex $allEntries 2]]}
    assert {[dict_in [dict create \
                      bucket $bucket \
                      key key2 \
                      value {} \
                      operation DEL] [lindex $allEntries 3]]}
} -result "" -cleanup {
    $watcher destroy
    set allEntries [list]
}

test key_value_watchers-watch-2 "Watch a wildcard" -body {
    set watcher [$kv watch keys.* -callback $watcherCallback -ignore_deletes true]
    $kv put keys.1 value1
    $kv delete keys.1
    $kv put keys.2 value2
    while {[llength $allEntries] < 3} {
        wait_for ::allEntries
    }
    assert {[lindex $allEntries 0] eq ""}
    assert {[dict_in [dict create \
                      bucket $bucket \
                      key keys.1 \
                      value value1 \
                      operation PUT] [lindex $allEntries 1]]}
    assert {[dict_in [dict create \
                      bucket $bucket \
                      key keys.2 \
                      value value2 \
                      operation PUT] [lindex $allEntries 2]]}
} -result "" -cleanup {
    $watcher destroy
    set allEntries [list]
}

$kv destroy
$js delete_kv_bucket $bucket
$js destroy
$conn destroy
stopNats NATS_JS

tcltest::cleanupTests
return

test key_value_watchers-history-2 "Get history for a bucket" -setup {
    execNatsCmd kv add $bucket --history=10
    execNatsCmd kv put $bucket key1 value1_1
    execNatsCmd kv put $bucket key1 value1_2
    execNatsCmd kv put $bucket key2 value2_1
    execNatsCmd kv put $bucket key2 value2_2
    execNatsCmd kv put $bucket key1 value1_3
    execNatsCmd kv put $bucket key3 value3_1
} -body {
    set entries [$kv history]

    sortAndCheckEntries $entries
} -result [list \
    [list bucket $bucket key key1 operation PUT revision 1 value value1_1] \
    [list bucket $bucket key key1 operation PUT revision 2 value value1_2] \
    [list bucket $bucket key key2 operation PUT revision 3 value value2_1] \
    [list bucket $bucket key key2 operation PUT revision 4 value value2_2] \
    [list bucket $bucket key key1 operation PUT revision 5 value value1_3] \
    [list bucket $bucket key key3 operation PUT revision 6 value value3_1] \
] -cleanup {
    execNatsCmd kv del $bucket -f
}

test key_value_watchers-history-3 "Get history for specific key with delete operation" -setup {
    execNatsCmd kv add $bucket --history=10
    execNatsCmd kv put $bucket key1 value1_1
    execNatsCmd kv put $bucket key1 value1_2
    execNatsCmd kv del $bucket key1 -f
    execNatsCmd kv put $bucket key1 value1_3
} -body {
    set entries [$kv history key1]

    sortAndCheckEntries $entries
} -result [list \
    [list bucket $bucket key key1 operation PUT revision 1 value value1_1] \
    [list bucket $bucket key key1 operation PUT revision 2 value value1_2] \
    [list bucket $bucket key key1 operation DEL revision 3 value {}] \
    [list bucket $bucket key key1 operation PUT revision 4 value value1_3] \
] -cleanup {
    execNatsCmd kv del $bucket -f
}

test key_value_watchers-history-4 "Get history for specific key with purge operation" -setup {
    execNatsCmd kv add $bucket --history=10
    execNatsCmd kv put $bucket key1 value1_1
    execNatsCmd kv purge -f $bucket key1
    execNatsCmd kv put $bucket key1 value1_2
} -body {
    set value [$kv history key1]

    lmap entry $value {
        # omit "created" timestamp
        set filtered_entry [dict filter $entry key value key bucket operation revision]
        # sort by key name
        lsort -stride 2 -index 0 $filtered_entry
    }
} -result [list \
    [list bucket $bucket key key1 operation PURGE revision 2 value {}] \
    [list bucket $bucket key key1 operation PUT revision 3 value value1_2] \
] -cleanup {
    execNatsCmd kv del $bucket -f
}

test key_value_watchers-history-5 "Returns immediately when there is no values" -setup {
    execNatsCmd kv add $bucket --history=10
} -body {
    $kv history key1
} -result {} -cleanup {
    execNatsCmd kv del $bucket -f
}

test key_value_watchers-history-6 "Throws when there is no bucket" -body {
    if {![catch {
        $kv history
    } err errOpts]} {
        throw {TEST DidNotThrow} "Did not throw"
    }
    assert {[dict get $errOpts -errorcode] eq {NATS BucketNotFound}}
    set err
} -result "Bucket $bucket not found"

########### KEYS ###########

test key_value_watchers-keys-1 "List keys" -setup {
    execNatsCmd kv add $bucket
    execNatsCmd kv put $bucket k1 val1
    execNatsCmd kv put $bucket k2 val2
} -body {
    $kv keys
} -result "k1 k2" -cleanup {
    execNatsCmd kv del $bucket -f
}

test key_value_watchers-keys-2 "List keys for empty bucket returns empty array" -setup {
    execNatsCmd kv add $bucket
} -body {
    $kv keys
} -result "" -cleanup {
    execNatsCmd kv del $bucket -f
}

test key_value_watchers-keys-3 "List keys for deleted entries should not return them" -setup {
    execNatsCmd kv add $bucket
    execNatsCmd kv put $bucket k1 val1
    execNatsCmd kv del -f $bucket k1
    execNatsCmd kv put $bucket k2 val2
    execNatsCmd kv put $bucket k3 val1
    execNatsCmd kv purge -f $bucket k3
} -body {
    $kv keys
} -result "k2" -cleanup {
    execNatsCmd kv del -f $bucket
}

test key_value_watchers-keys-4 "Throws when there is no bucket" -body {
    if {![catch {
        $kv keys
    } err errOpts]} {
        throw {TEST DidNotThrow} "Did not throw"
    }
    assert {[dict get $errOpts -errorcode] eq {NATS BucketNotFound}}
    set err
} -result "Bucket $bucket not found"

########## WATCH ##########

test key_value_watchers-watch-1 "Watch simple key" -setup {
    set ::received [list]
    unset -nocomplain ::complete
    execNatsCmd kv add $bucket
    execNatsCmd kv put $bucket key1 value1_1
    execNatsCmd kv put $bucket key1 value1_2
} -body {
    set ::expected_count 2
    set watchID [$kv watch key1 -callback exampleCallback]
    after 5000 [list set ::complete true] ;# timeout

    vwait ::complete
    after cancel [list set ::complete true]
    if {[llength $::received] != $::expected_count} {
        throw {TEST NotEnoughCalls} "Callback was not received expected number of times. Expected: $::expected_count, got: [llength $::received] ($::received)"
    }

    sortAndCheckWatchCallbacks $::received
} -result [list \
    [list {} [list bucket $bucket key key1 operation PUT revision 2 value value1_2]] \
    [list end_of_initial_data {}] \
] -cleanup {
    $kv unwatch $watchID
    execNatsCmd kv del $bucket -f
}

test key_value_watchers-watch-2 "Watch multiple keys" -setup {
    set ::received [list]
    unset -nocomplain ::complete
    execNatsCmd kv add $bucket
    execNatsCmd kv put $bucket key1 value1_1
    execNatsCmd kv put $bucket key1 value1_2
    execNatsCmd kv put $bucket key2 value2_1
    execNatsCmd kv put $bucket key3 value3_1
} -body {
    set ::expected_count 4
    set watchID [$kv watch -callback exampleCallback]
    after 5000 [list set ::complete true] ;# timeout

    vwait ::complete
    after cancel [list set ::complete true]
    if {[llength $::received] != $::expected_count} {
        throw {TEST NotEnoughCalls} "Callback was not received expected number of times. Expected: $::expected_count, got: [llength $::received] ($::received)"
    }

    sortAndCheckWatchCallbacks $::received
} -result [list \
    [list {} [list bucket $bucket key key1 operation PUT revision 2 value value1_2]] \
    [list {} [list bucket $bucket key key2 operation PUT revision 3 value value2_1]] \
    [list {} [list bucket $bucket key key3 operation PUT revision 4 value value3_1]] \
    [list end_of_initial_data {}] \
] -cleanup {
    $kv unwatch $watchID
    execNatsCmd kv del $bucket -f
}

test key_value_watchers-watch-3 "Watch key with history" -setup {
    set ::received [list]
    unset -nocomplain ::complete
    execNatsCmd kv add $bucket --history=10
    execNatsCmd kv put $bucket key1 value1_1
    execNatsCmd kv put $bucket key1 value1_2
    execNatsCmd kv put $bucket key1 value1_3
} -body {
    set ::expected_count 4
    set watchID [$kv watch key1 -callback exampleCallback -include_history true]
    after 5000 [list set ::complete true] ;# timeout

    vwait ::complete
    after cancel [list set ::complete true]
    if {[llength $::received] != $::expected_count} {
        throw {TEST NotEnoughCalls} "Callback was not received expected number of times. Expected: $::expected_count, got: [llength $::received] ($::received)"
    }

    sortAndCheckWatchCallbacks $::received
} -result [list \
    [list {} [list bucket $bucket key key1 operation PUT revision 1 value value1_1]] \
    [list {} [list bucket $bucket key key1 operation PUT revision 2 value value1_2]] \
    [list {} [list bucket $bucket key key1 operation PUT revision 3 value value1_3]] \
    [list end_of_initial_data {}] \
] -cleanup {
    $kv unwatch $watchID
    execNatsCmd kv del $bucket -f
}

test key_value_watchers-watch-4 "Watch key with history, purge and delete operations" -setup {
    set ::received [list]
    unset -nocomplain ::complete
    execNatsCmd kv add $bucket --history=10
    execNatsCmd kv put $bucket key1 value1_1
    execNatsCmd kv purge -f $bucket key1
    execNatsCmd kv put $bucket key1 value1_2
    execNatsCmd kv put $bucket key1 value1_3
    execNatsCmd kv del -f $bucket key1
    execNatsCmd kv put $bucket key1 value1_4
} -body {
    set ::expected_count 6
    set watchID [$kv watch key1 -callback exampleCallback -include_history true]
    after 5000 [list set ::complete true] ;# timeout

    vwait ::complete
    after cancel [list set ::complete true]
    if {[llength $::received] < $::expected_count} {
        throw {TEST NotEnoughCalls} "Callback was not received expected number of times. Expected: $::expected_count, got: [llength $::received] ($::received)"
    }

    sortAndCheckWatchCallbacks $::received
} -result [list \
    [list {} [list bucket $bucket key key1 operation PURGE revision 2 value {}]] \
    [list {} [list bucket $bucket key key1 operation PUT revision 3 value value1_2]] \
    [list {} [list bucket $bucket key key1 operation PUT revision 4 value value1_3]] \
    [list {} [list bucket $bucket key key1 operation DEL revision 5 value {}]] \
    [list {} [list bucket $bucket key key1 operation PUT revision 6 value value1_4]] \
    [list end_of_initial_data {}] \
] -cleanup {
    $kv unwatch $watchID
    execNatsCmd kv del $bucket -f
}

test key_value_watchers-watch-5 "Watch key with meta only and history, with purge and delete operations" -setup {
    set ::received [list]
    unset -nocomplain ::complete
    execNatsCmd kv add $bucket --history=10
    execNatsCmd kv put $bucket key1 value1_1
    execNatsCmd kv purge -f $bucket key1
    execNatsCmd kv put $bucket key1 value1_2
    execNatsCmd kv del -f $bucket key1
    execNatsCmd kv put $bucket key1 value1_3
} -body {
    set ::expected_count 5
    set watchID [$kv watch key1 -callback exampleCallback -meta_only true -include_history true]
    after 5000 [list set ::complete true] ;# timeout

    vwait ::complete
    after cancel [list set ::complete true]
    if {[llength $::received] < $::expected_count} {
        throw {TEST NotEnoughCalls} "Callback was not received expected number of times. Expected: $::expected_count, got: [llength $::received] ($::received)"
    }

    sortAndCheckWatchCallbacks $::received
} -result [list \
    [list {} [list bucket $bucket key key1 operation PURGE revision 2 value {}]] \
    [list {} [list bucket $bucket key key1 operation PUT revision 3 value {}]] \
    [list {} [list bucket $bucket key key1 operation DEL revision 4 value {}]] \
    [list {} [list bucket $bucket key key1 operation PUT revision 5 value {}]] \
    [list end_of_initial_data {}] \
] -cleanup {
    $kv unwatch $watchID
    execNatsCmd kv del $bucket -f
}

test key_value_watchers-watch-6 "Watch key with history and ignore deletes" -setup {
    set ::received [list]
    unset -nocomplain ::complete
    execNatsCmd kv add $bucket --history=10
    execNatsCmd kv put $bucket key1 value1_1
    execNatsCmd kv purge -f $bucket key1
    execNatsCmd kv put $bucket key1 value1_2
    execNatsCmd kv del -f $bucket key1
    execNatsCmd kv put $bucket key1 value1_3
} -body {
    set ::expected_count 3
    set watchID [$kv watch key1 -callback exampleCallback -ignore_deletes true -include_history true]
    after 5000 [list set ::complete true] ;# timeout

    vwait ::complete
    after cancel [list set ::complete true]
    if {[llength $::received] < $::expected_count} {
        throw {TEST NotEnoughCalls} "Callback was not received expected number of times. Expected: $::expected_count, got: [llength $::received] ($::received)"
    }

    sortAndCheckWatchCallbacks $::received
} -result [list \
    [list {} [list bucket $bucket key key1 operation PUT revision 3 value value1_2]] \
    [list {} [list bucket $bucket key key1 operation PUT revision 5 value value1_3]] \
    [list end_of_initial_data {}] \
] -cleanup {
    $kv unwatch $watchID
    execNatsCmd kv del $bucket -f
}

test key_value_watchers-watch-7 "Watch key with updates only" -setup {
    set ::received [list]
    unset -nocomplain ::complete
    execNatsCmd kv add $bucket --history=10
    execNatsCmd kv put $bucket key1 value1_1
} -body {
    set ::expected_count 2
    set watchID [$kv watch key1 -callback exampleCallback -updates_only true -idle_heartbeat 1000]
    after 3000 [list execNatsCmd kv put $bucket key1 value1_2] ;# do it after first heartbeat and end of initial data
    after 10000 [list set ::complete true] ;# timeout

    vwait ::complete
    after cancel [list set ::complete true]
    if {[llength $::received] < $::expected_count} {
        throw {TEST NotEnoughCalls} "Callback was not received expected number of times. Expected: $::expected_count, got: [llength $::received] ($::received)"
    }

    sortAndCheckWatchCallbacks $::received
} -result [list \
    [list end_of_initial_data {}] \
    [list {} [list bucket $bucket key key1 operation PUT revision 2 value value1_2]] \
] -cleanup {
    $kv unwatch $watchID
    execNatsCmd kv del $bucket -f
}

test key_value_watchers-watch-8 "Watching key should continue after server restart" -setup {
    set ::received [list]
    unset -nocomplain ::complete
    execNatsCmd kv add $bucket --history=10
} -body {
    set ::expected_count 2
    set watchID [$kv watch key1 -callback exampleCallback -updates_only true -idle_heartbeat 1000]
    
    # restart server - it would re-create consumer automatically
    after 2000 [list stopNats NATS_JS]
    after 2500 [list startNats NATS_JS -js --store_dir [tcltest::temporaryDirectory];]

    after 4000 [list execNatsCmd kv put $bucket key1 value1_1]
    after 10000 [list set ::complete true] ;# timeout

    vwait ::complete
    after cancel [list set ::complete true]
    if {[llength $::received] < $::expected_count} {
        throw {TEST NotEnoughCalls} "Callback was not received expected number of times. Expected: $::expected_count, got: [llength $::received] ($::received)"
    }

    sortAndCheckWatchCallbacks $::received
} -result [list \
    [list end_of_initial_data {}] \
    [list {} [list bucket $bucket key key1 operation PUT revision 1 value value1_1]] \
] -cleanup {
    $kv unwatch $watchID
    execNatsCmd kv del $bucket -f
}

test key_value_watchers-watch-9 "Watching key should continue and user should bo notified after server has been down for some time (more than 3 heartbeats)" -setup {
    set ::received [list]
    unset -nocomplain ::complete
    execNatsCmd kv add $bucket --history=10
} -body {
    set ::expected_count 4 ;# if server has been down for long time user should be notified
    set watchID [$kv watch key1 -callback exampleCallback -updates_only true -idle_heartbeat 500]
    
    after 2000 [list stopNats NATS_JS]
    after 5000 [list startNats NATS_JS -js --store_dir [tcltest::temporaryDirectory];]

    after 7000 [list execNatsCmd kv put $bucket key1 value1_1]
    after 10000 [list set ::complete true] ;# timeout

    vwait ::complete
    after cancel [list set ::complete true]
    if {[llength $::received] < $::expected_count} {
        throw {TEST NotEnoughCalls} "Callback was not received expected number of times. Expected: $::expected_count, got: [llength $::received] ($::received)"
    }

    sortAndCheckWatchCallbacks $::received
} -result [list \
    [list end_of_initial_data {}] \
    [list error "Server disconnected"] \
    [list ok {}] \
    [list {} [list bucket $bucket key key1 operation PUT revision 1 value value1_1]] \
] -cleanup {
    $kv unwatch $watchID
    execNatsCmd kv del $bucket -f
}

test key_value_watchers-watch-10 "Watching key should continue and consumer should be re-created after it has been somehow removed" -setup {
    set ::received [list]
    unset -nocomplain ::complete
    execNatsCmd kv add $bucket --history=10
} -body {
    set ::expected_count 2
    set watchID [$kv watch key1 -callback exampleCallback -updates_only true -idle_heartbeat 500]

    set consumers [$js consumer_names KV_${bucket}]
    # there should be only one consumer for this bucket
    assert {[llength $consumers] == 1}
    set first_consumer [lindex $consumers 0]

    after 1000 [list $js delete_consumer KV_${bucket} $first_consumer]

    # consumer should be re-created at this point
    after 5000 [list execNatsCmd kv put $bucket key1 value1_1]
    after 10000 [list set ::complete true] ;# timeout

    vwait ::complete
    after cancel [list set ::complete true]

    set consumers [$js consumer_names KV_${bucket}]
    # there should still be only one consumer that is different than previous
    assert {[llength $consumers] == 1}
    set seconds_consumer [lindex $consumers 0]
    assert {$seconds_consumer != $first_consumer}

    if {[llength $::received] < $::expected_count} {
        throw {TEST NotEnoughCalls} "Callback was not received expected number of times. Expected: $::expected_count, got: [llength $::received] ($::received)"
    }

    sortAndCheckWatchCallbacks $::received
} -result [list \
    [list end_of_initial_data {}] \
    [list {} [list bucket $bucket key key1 operation PUT revision 1 value value1_1]] \
] -cleanup {
    $kv unwatch $watchID
    execNatsCmd kv del $bucket -f
}

$kv destroy
$js destroy
$conn destroy
stopNats NATS_JS

tcltest::cleanupTests
